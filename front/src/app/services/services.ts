// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v6.30.2
// source: services.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "proto";

export enum Role {
  ROLE_UNKNOWN = 0,
  ROLE_MEMBER = 1,
  ROLE_ADMIN = 2,
  UNRECOGNIZED = -1,
}

export function roleFromJSON(object: any): Role {
  switch (object) {
    case 0:
    case "ROLE_UNKNOWN":
      return Role.ROLE_UNKNOWN;
    case 1:
    case "ROLE_MEMBER":
      return Role.ROLE_MEMBER;
    case 2:
    case "ROLE_ADMIN":
      return Role.ROLE_ADMIN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Role.UNRECOGNIZED;
  }
}

export function roleToJSON(object: Role): string {
  switch (object) {
    case Role.ROLE_UNKNOWN:
      return "ROLE_UNKNOWN";
    case Role.ROLE_MEMBER:
      return "ROLE_MEMBER";
    case Role.ROLE_ADMIN:
      return "ROLE_ADMIN";
    case Role.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum QuestionState {
  QUESTION_STATE_UNKNOWN = 0,
  QUESTION_STATE_DRAFT = 1,
  QUESTION_STATE_PUBLISHED = 2,
  UNRECOGNIZED = -1,
}

export function questionStateFromJSON(object: any): QuestionState {
  switch (object) {
    case 0:
    case "QUESTION_STATE_UNKNOWN":
      return QuestionState.QUESTION_STATE_UNKNOWN;
    case 1:
    case "QUESTION_STATE_DRAFT":
      return QuestionState.QUESTION_STATE_DRAFT;
    case 2:
    case "QUESTION_STATE_PUBLISHED":
      return QuestionState.QUESTION_STATE_PUBLISHED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return QuestionState.UNRECOGNIZED;
  }
}

export function questionStateToJSON(object: QuestionState): string {
  switch (object) {
    case QuestionState.QUESTION_STATE_UNKNOWN:
      return "QUESTION_STATE_UNKNOWN";
    case QuestionState.QUESTION_STATE_DRAFT:
      return "QUESTION_STATE_DRAFT";
    case QuestionState.QUESTION_STATE_PUBLISHED:
      return "QUESTION_STATE_PUBLISHED";
    case QuestionState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SubmissionState {
  SUBMISSION_STATE_UNKNOWN = 0,
  SUBMISSION_STATE_PENDING = 1,
  SUBMISSION_STATE_JUDGING = 2,
  SUBMISSION_STATE_OK = 3,
  SUBMISSION_STATE_COMPILE_ERROR = 4,
  SUBMISSION_STATE_WRONG_ANSWER = 5,
  SUBMISSION_STATE_MEMORY_LIMIT_EXCEEDED = 6,
  SUBMISSION_STATE_TIME_LIMIT_EXCEEDED = 7,
  SUBMISSION_STATE_RUNTIME_ERROR = 8,
  UNRECOGNIZED = -1,
}

export function submissionStateFromJSON(object: any): SubmissionState {
  switch (object) {
    case 0:
    case "SUBMISSION_STATE_UNKNOWN":
      return SubmissionState.SUBMISSION_STATE_UNKNOWN;
    case 1:
    case "SUBMISSION_STATE_PENDING":
      return SubmissionState.SUBMISSION_STATE_PENDING;
    case 2:
    case "SUBMISSION_STATE_JUDGING":
      return SubmissionState.SUBMISSION_STATE_JUDGING;
    case 3:
    case "SUBMISSION_STATE_OK":
      return SubmissionState.SUBMISSION_STATE_OK;
    case 4:
    case "SUBMISSION_STATE_COMPILE_ERROR":
      return SubmissionState.SUBMISSION_STATE_COMPILE_ERROR;
    case 5:
    case "SUBMISSION_STATE_WRONG_ANSWER":
      return SubmissionState.SUBMISSION_STATE_WRONG_ANSWER;
    case 6:
    case "SUBMISSION_STATE_MEMORY_LIMIT_EXCEEDED":
      return SubmissionState.SUBMISSION_STATE_MEMORY_LIMIT_EXCEEDED;
    case 7:
    case "SUBMISSION_STATE_TIME_LIMIT_EXCEEDED":
      return SubmissionState.SUBMISSION_STATE_TIME_LIMIT_EXCEEDED;
    case 8:
    case "SUBMISSION_STATE_RUNTIME_ERROR":
      return SubmissionState.SUBMISSION_STATE_RUNTIME_ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SubmissionState.UNRECOGNIZED;
  }
}

export function submissionStateToJSON(object: SubmissionState): string {
  switch (object) {
    case SubmissionState.SUBMISSION_STATE_UNKNOWN:
      return "SUBMISSION_STATE_UNKNOWN";
    case SubmissionState.SUBMISSION_STATE_PENDING:
      return "SUBMISSION_STATE_PENDING";
    case SubmissionState.SUBMISSION_STATE_JUDGING:
      return "SUBMISSION_STATE_JUDGING";
    case SubmissionState.SUBMISSION_STATE_OK:
      return "SUBMISSION_STATE_OK";
    case SubmissionState.SUBMISSION_STATE_COMPILE_ERROR:
      return "SUBMISSION_STATE_COMPILE_ERROR";
    case SubmissionState.SUBMISSION_STATE_WRONG_ANSWER:
      return "SUBMISSION_STATE_WRONG_ANSWER";
    case SubmissionState.SUBMISSION_STATE_MEMORY_LIMIT_EXCEEDED:
      return "SUBMISSION_STATE_MEMORY_LIMIT_EXCEEDED";
    case SubmissionState.SUBMISSION_STATE_TIME_LIMIT_EXCEEDED:
      return "SUBMISSION_STATE_TIME_LIMIT_EXCEEDED";
    case SubmissionState.SUBMISSION_STATE_RUNTIME_ERROR:
      return "SUBMISSION_STATE_RUNTIME_ERROR";
    case SubmissionState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface AuthenticationRequest {
  username: string;
  password: string;
}

export interface AuthenticationResponse {
  value: string;
}

export interface ChangeRoleRequest {
  username: string;
  role: Role;
}

export interface Empty {
}

export interface GetProfileResponse {
  username: string;
}

export interface GetProfilesResponse {
  usernames: string[];
}

export interface GetStatsResponse {
  triedQuestions: number;
  solvedQuestions: number;
}

export interface Question {
  id?: string | undefined;
  title: string;
  statement: string;
  limitations: Limitations | undefined;
  input?: string | undefined;
  output?: string | undefined;
  state: QuestionState;
}

export interface Limitations {
  /** milliseconds */
  duration: number;
  /** mega bytes */
  memory: number;
}

export interface Filter {
  field: string;
  value: string;
}

export interface GetQuestionsRequest {
  filters: Filter[];
}

export interface GetQuestionsResponse {
  questions: Question[];
}

export interface GetQuestionResponse {
  question: Question | undefined;
}

export interface SubmitRequest {
  submission: Submission | undefined;
}

export interface GetSubmissionsRequest {
  filters: Filter[];
}

export interface Submission {
  id?: string | undefined;
  questionId: string;
  state?: SubmissionState | undefined;
  code: Uint8Array;
}

export interface GetSubmissionsResponse {
  submissions: Submission[];
}

export interface ID {
  value: string;
}

export interface ChangeQuestionStateRequest {
  questionId: string;
  state: QuestionState;
}

export interface UpdateSubmissionRequest {
  submissionId: string;
  state: SubmissionState;
}

function createBaseAuthenticationRequest(): AuthenticationRequest {
  return { username: "", password: "" };
}

export const AuthenticationRequest: MessageFns<AuthenticationRequest> = {
  encode(message: AuthenticationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthenticationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthenticationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthenticationRequest {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
    };
  },

  toJSON(message: AuthenticationRequest): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthenticationRequest>, I>>(base?: I): AuthenticationRequest {
    return AuthenticationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthenticationRequest>, I>>(object: I): AuthenticationRequest {
    const message = createBaseAuthenticationRequest();
    message.username = object.username ?? "";
    message.password = object.password ?? "";
    return message;
  },
};

function createBaseAuthenticationResponse(): AuthenticationResponse {
  return { value: "" };
}

export const AuthenticationResponse: MessageFns<AuthenticationResponse> = {
  encode(message: AuthenticationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthenticationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthenticationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthenticationResponse {
    return { value: isSet(object.value) ? globalThis.String(object.value) : "" };
  },

  toJSON(message: AuthenticationResponse): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthenticationResponse>, I>>(base?: I): AuthenticationResponse {
    return AuthenticationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthenticationResponse>, I>>(object: I): AuthenticationResponse {
    const message = createBaseAuthenticationResponse();
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseChangeRoleRequest(): ChangeRoleRequest {
  return { username: "", role: 0 };
}

export const ChangeRoleRequest: MessageFns<ChangeRoleRequest> = {
  encode(message: ChangeRoleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.role !== 0) {
      writer.uint32(16).int32(message.role);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangeRoleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangeRoleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.role = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangeRoleRequest {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      role: isSet(object.role) ? roleFromJSON(object.role) : 0,
    };
  },

  toJSON(message: ChangeRoleRequest): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.role !== 0) {
      obj.role = roleToJSON(message.role);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChangeRoleRequest>, I>>(base?: I): ChangeRoleRequest {
    return ChangeRoleRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChangeRoleRequest>, I>>(object: I): ChangeRoleRequest {
    const message = createBaseChangeRoleRequest();
    message.username = object.username ?? "";
    message.role = object.role ?? 0;
    return message;
  },
};

function createBaseEmpty(): Empty {
  return {};
}

export const Empty: MessageFns<Empty> = {
  encode(_: Empty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Empty {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmpty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Empty {
    return {};
  },

  toJSON(_: Empty): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Empty>, I>>(base?: I): Empty {
    return Empty.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Empty>, I>>(_: I): Empty {
    const message = createBaseEmpty();
    return message;
  },
};

function createBaseGetProfileResponse(): GetProfileResponse {
  return { username: "" };
}

export const GetProfileResponse: MessageFns<GetProfileResponse> = {
  encode(message: GetProfileResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProfileResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProfileResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProfileResponse {
    return { username: isSet(object.username) ? globalThis.String(object.username) : "" };
  },

  toJSON(message: GetProfileResponse): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProfileResponse>, I>>(base?: I): GetProfileResponse {
    return GetProfileResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProfileResponse>, I>>(object: I): GetProfileResponse {
    const message = createBaseGetProfileResponse();
    message.username = object.username ?? "";
    return message;
  },
};

function createBaseGetProfilesResponse(): GetProfilesResponse {
  return { usernames: [] };
}

export const GetProfilesResponse: MessageFns<GetProfilesResponse> = {
  encode(message: GetProfilesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.usernames) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProfilesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProfilesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.usernames.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProfilesResponse {
    return {
      usernames: globalThis.Array.isArray(object?.usernames)
        ? object.usernames.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: GetProfilesResponse): unknown {
    const obj: any = {};
    if (message.usernames?.length) {
      obj.usernames = message.usernames;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProfilesResponse>, I>>(base?: I): GetProfilesResponse {
    return GetProfilesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProfilesResponse>, I>>(object: I): GetProfilesResponse {
    const message = createBaseGetProfilesResponse();
    message.usernames = object.usernames?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetStatsResponse(): GetStatsResponse {
  return { triedQuestions: 0, solvedQuestions: 0 };
}

export const GetStatsResponse: MessageFns<GetStatsResponse> = {
  encode(message: GetStatsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.triedQuestions !== 0) {
      writer.uint32(8).int64(message.triedQuestions);
    }
    if (message.solvedQuestions !== 0) {
      writer.uint32(16).int64(message.solvedQuestions);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStatsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStatsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.triedQuestions = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.solvedQuestions = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStatsResponse {
    return {
      triedQuestions: isSet(object.triedQuestions) ? globalThis.Number(object.triedQuestions) : 0,
      solvedQuestions: isSet(object.solvedQuestions) ? globalThis.Number(object.solvedQuestions) : 0,
    };
  },

  toJSON(message: GetStatsResponse): unknown {
    const obj: any = {};
    if (message.triedQuestions !== 0) {
      obj.triedQuestions = Math.round(message.triedQuestions);
    }
    if (message.solvedQuestions !== 0) {
      obj.solvedQuestions = Math.round(message.solvedQuestions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetStatsResponse>, I>>(base?: I): GetStatsResponse {
    return GetStatsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetStatsResponse>, I>>(object: I): GetStatsResponse {
    const message = createBaseGetStatsResponse();
    message.triedQuestions = object.triedQuestions ?? 0;
    message.solvedQuestions = object.solvedQuestions ?? 0;
    return message;
  },
};

function createBaseQuestion(): Question {
  return {
    id: undefined,
    title: "",
    statement: "",
    limitations: undefined,
    input: undefined,
    output: undefined,
    state: 0,
  };
}

export const Question: MessageFns<Question> = {
  encode(message: Question, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      writer.uint32(10).string(message.id);
    }
    if (message.title !== "") {
      writer.uint32(18).string(message.title);
    }
    if (message.statement !== "") {
      writer.uint32(26).string(message.statement);
    }
    if (message.limitations !== undefined) {
      Limitations.encode(message.limitations, writer.uint32(34).fork()).join();
    }
    if (message.input !== undefined) {
      writer.uint32(42).string(message.input);
    }
    if (message.output !== undefined) {
      writer.uint32(50).string(message.output);
    }
    if (message.state !== 0) {
      writer.uint32(56).int32(message.state);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Question {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuestion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.statement = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.limitations = Limitations.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.input = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.output = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Question {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : undefined,
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      statement: isSet(object.statement) ? globalThis.String(object.statement) : "",
      limitations: isSet(object.limitations) ? Limitations.fromJSON(object.limitations) : undefined,
      input: isSet(object.input) ? globalThis.String(object.input) : undefined,
      output: isSet(object.output) ? globalThis.String(object.output) : undefined,
      state: isSet(object.state) ? questionStateFromJSON(object.state) : 0,
    };
  },

  toJSON(message: Question): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = message.id;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.statement !== "") {
      obj.statement = message.statement;
    }
    if (message.limitations !== undefined) {
      obj.limitations = Limitations.toJSON(message.limitations);
    }
    if (message.input !== undefined) {
      obj.input = message.input;
    }
    if (message.output !== undefined) {
      obj.output = message.output;
    }
    if (message.state !== 0) {
      obj.state = questionStateToJSON(message.state);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Question>, I>>(base?: I): Question {
    return Question.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Question>, I>>(object: I): Question {
    const message = createBaseQuestion();
    message.id = object.id ?? undefined;
    message.title = object.title ?? "";
    message.statement = object.statement ?? "";
    message.limitations = (object.limitations !== undefined && object.limitations !== null)
      ? Limitations.fromPartial(object.limitations)
      : undefined;
    message.input = object.input ?? undefined;
    message.output = object.output ?? undefined;
    message.state = object.state ?? 0;
    return message;
  },
};

function createBaseLimitations(): Limitations {
  return { duration: 0, memory: 0 };
}

export const Limitations: MessageFns<Limitations> = {
  encode(message: Limitations, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.duration !== 0) {
      writer.uint32(8).int64(message.duration);
    }
    if (message.memory !== 0) {
      writer.uint32(16).int64(message.memory);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Limitations {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLimitations();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.duration = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.memory = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Limitations {
    return {
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      memory: isSet(object.memory) ? globalThis.Number(object.memory) : 0,
    };
  },

  toJSON(message: Limitations): unknown {
    const obj: any = {};
    if (message.duration !== 0) {
      obj.duration = Math.round(message.duration);
    }
    if (message.memory !== 0) {
      obj.memory = Math.round(message.memory);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Limitations>, I>>(base?: I): Limitations {
    return Limitations.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Limitations>, I>>(object: I): Limitations {
    const message = createBaseLimitations();
    message.duration = object.duration ?? 0;
    message.memory = object.memory ?? 0;
    return message;
  },
};

function createBaseFilter(): Filter {
  return { field: "", value: "" };
}

export const Filter: MessageFns<Filter> = {
  encode(message: Filter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.field !== "") {
      writer.uint32(10).string(message.field);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Filter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.field = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Filter {
    return {
      field: isSet(object.field) ? globalThis.String(object.field) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Filter): unknown {
    const obj: any = {};
    if (message.field !== "") {
      obj.field = message.field;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Filter>, I>>(base?: I): Filter {
    return Filter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Filter>, I>>(object: I): Filter {
    const message = createBaseFilter();
    message.field = object.field ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseGetQuestionsRequest(): GetQuestionsRequest {
  return { filters: [] };
}

export const GetQuestionsRequest: MessageFns<GetQuestionsRequest> = {
  encode(message: GetQuestionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.filters) {
      Filter.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetQuestionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetQuestionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filters.push(Filter.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetQuestionsRequest {
    return {
      filters: globalThis.Array.isArray(object?.filters) ? object.filters.map((e: any) => Filter.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetQuestionsRequest): unknown {
    const obj: any = {};
    if (message.filters?.length) {
      obj.filters = message.filters.map((e) => Filter.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetQuestionsRequest>, I>>(base?: I): GetQuestionsRequest {
    return GetQuestionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetQuestionsRequest>, I>>(object: I): GetQuestionsRequest {
    const message = createBaseGetQuestionsRequest();
    message.filters = object.filters?.map((e) => Filter.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetQuestionsResponse(): GetQuestionsResponse {
  return { questions: [] };
}

export const GetQuestionsResponse: MessageFns<GetQuestionsResponse> = {
  encode(message: GetQuestionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.questions) {
      Question.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetQuestionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetQuestionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.questions.push(Question.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetQuestionsResponse {
    return {
      questions: globalThis.Array.isArray(object?.questions)
        ? object.questions.map((e: any) => Question.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetQuestionsResponse): unknown {
    const obj: any = {};
    if (message.questions?.length) {
      obj.questions = message.questions.map((e) => Question.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetQuestionsResponse>, I>>(base?: I): GetQuestionsResponse {
    return GetQuestionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetQuestionsResponse>, I>>(object: I): GetQuestionsResponse {
    const message = createBaseGetQuestionsResponse();
    message.questions = object.questions?.map((e) => Question.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetQuestionResponse(): GetQuestionResponse {
  return { question: undefined };
}

export const GetQuestionResponse: MessageFns<GetQuestionResponse> = {
  encode(message: GetQuestionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.question !== undefined) {
      Question.encode(message.question, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetQuestionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetQuestionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.question = Question.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetQuestionResponse {
    return { question: isSet(object.question) ? Question.fromJSON(object.question) : undefined };
  },

  toJSON(message: GetQuestionResponse): unknown {
    const obj: any = {};
    if (message.question !== undefined) {
      obj.question = Question.toJSON(message.question);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetQuestionResponse>, I>>(base?: I): GetQuestionResponse {
    return GetQuestionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetQuestionResponse>, I>>(object: I): GetQuestionResponse {
    const message = createBaseGetQuestionResponse();
    message.question = (object.question !== undefined && object.question !== null)
      ? Question.fromPartial(object.question)
      : undefined;
    return message;
  },
};

function createBaseSubmitRequest(): SubmitRequest {
  return { submission: undefined };
}

export const SubmitRequest: MessageFns<SubmitRequest> = {
  encode(message: SubmitRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.submission !== undefined) {
      Submission.encode(message.submission, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubmitRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmitRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.submission = Submission.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubmitRequest {
    return { submission: isSet(object.submission) ? Submission.fromJSON(object.submission) : undefined };
  },

  toJSON(message: SubmitRequest): unknown {
    const obj: any = {};
    if (message.submission !== undefined) {
      obj.submission = Submission.toJSON(message.submission);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SubmitRequest>, I>>(base?: I): SubmitRequest {
    return SubmitRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SubmitRequest>, I>>(object: I): SubmitRequest {
    const message = createBaseSubmitRequest();
    message.submission = (object.submission !== undefined && object.submission !== null)
      ? Submission.fromPartial(object.submission)
      : undefined;
    return message;
  },
};

function createBaseGetSubmissionsRequest(): GetSubmissionsRequest {
  return { filters: [] };
}

export const GetSubmissionsRequest: MessageFns<GetSubmissionsRequest> = {
  encode(message: GetSubmissionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.filters) {
      Filter.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSubmissionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSubmissionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filters.push(Filter.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSubmissionsRequest {
    return {
      filters: globalThis.Array.isArray(object?.filters) ? object.filters.map((e: any) => Filter.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetSubmissionsRequest): unknown {
    const obj: any = {};
    if (message.filters?.length) {
      obj.filters = message.filters.map((e) => Filter.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSubmissionsRequest>, I>>(base?: I): GetSubmissionsRequest {
    return GetSubmissionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSubmissionsRequest>, I>>(object: I): GetSubmissionsRequest {
    const message = createBaseGetSubmissionsRequest();
    message.filters = object.filters?.map((e) => Filter.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSubmission(): Submission {
  return { id: undefined, questionId: "", state: undefined, code: new Uint8Array(0) };
}

export const Submission: MessageFns<Submission> = {
  encode(message: Submission, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      writer.uint32(10).string(message.id);
    }
    if (message.questionId !== "") {
      writer.uint32(18).string(message.questionId);
    }
    if (message.state !== undefined) {
      writer.uint32(24).int32(message.state);
    }
    if (message.code.length !== 0) {
      writer.uint32(34).bytes(message.code);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Submission {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubmission();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.questionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.code = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Submission {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : undefined,
      questionId: isSet(object.questionId) ? globalThis.String(object.questionId) : "",
      state: isSet(object.state) ? submissionStateFromJSON(object.state) : undefined,
      code: isSet(object.code) ? bytesFromBase64(object.code) : new Uint8Array(0),
    };
  },

  toJSON(message: Submission): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = message.id;
    }
    if (message.questionId !== "") {
      obj.questionId = message.questionId;
    }
    if (message.state !== undefined) {
      obj.state = submissionStateToJSON(message.state);
    }
    if (message.code.length !== 0) {
      obj.code = base64FromBytes(message.code);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Submission>, I>>(base?: I): Submission {
    return Submission.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Submission>, I>>(object: I): Submission {
    const message = createBaseSubmission();
    message.id = object.id ?? undefined;
    message.questionId = object.questionId ?? "";
    message.state = object.state ?? undefined;
    message.code = object.code ?? new Uint8Array(0);
    return message;
  },
};

function createBaseGetSubmissionsResponse(): GetSubmissionsResponse {
  return { submissions: [] };
}

export const GetSubmissionsResponse: MessageFns<GetSubmissionsResponse> = {
  encode(message: GetSubmissionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.submissions) {
      Submission.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSubmissionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSubmissionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.submissions.push(Submission.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSubmissionsResponse {
    return {
      submissions: globalThis.Array.isArray(object?.submissions)
        ? object.submissions.map((e: any) => Submission.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GetSubmissionsResponse): unknown {
    const obj: any = {};
    if (message.submissions?.length) {
      obj.submissions = message.submissions.map((e) => Submission.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSubmissionsResponse>, I>>(base?: I): GetSubmissionsResponse {
    return GetSubmissionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSubmissionsResponse>, I>>(object: I): GetSubmissionsResponse {
    const message = createBaseGetSubmissionsResponse();
    message.submissions = object.submissions?.map((e) => Submission.fromPartial(e)) || [];
    return message;
  },
};

function createBaseID(): ID {
  return { value: "" };
}

export const ID: MessageFns<ID> = {
  encode(message: ID, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ID {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseID();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ID {
    return { value: isSet(object.value) ? globalThis.String(object.value) : "" };
  },

  toJSON(message: ID): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ID>, I>>(base?: I): ID {
    return ID.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ID>, I>>(object: I): ID {
    const message = createBaseID();
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseChangeQuestionStateRequest(): ChangeQuestionStateRequest {
  return { questionId: "", state: 0 };
}

export const ChangeQuestionStateRequest: MessageFns<ChangeQuestionStateRequest> = {
  encode(message: ChangeQuestionStateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.questionId !== "") {
      writer.uint32(10).string(message.questionId);
    }
    if (message.state !== 0) {
      writer.uint32(16).int32(message.state);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChangeQuestionStateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangeQuestionStateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.questionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangeQuestionStateRequest {
    return {
      questionId: isSet(object.questionId) ? globalThis.String(object.questionId) : "",
      state: isSet(object.state) ? questionStateFromJSON(object.state) : 0,
    };
  },

  toJSON(message: ChangeQuestionStateRequest): unknown {
    const obj: any = {};
    if (message.questionId !== "") {
      obj.questionId = message.questionId;
    }
    if (message.state !== 0) {
      obj.state = questionStateToJSON(message.state);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChangeQuestionStateRequest>, I>>(base?: I): ChangeQuestionStateRequest {
    return ChangeQuestionStateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChangeQuestionStateRequest>, I>>(object: I): ChangeQuestionStateRequest {
    const message = createBaseChangeQuestionStateRequest();
    message.questionId = object.questionId ?? "";
    message.state = object.state ?? 0;
    return message;
  },
};

function createBaseUpdateSubmissionRequest(): UpdateSubmissionRequest {
  return { submissionId: "", state: 0 };
}

export const UpdateSubmissionRequest: MessageFns<UpdateSubmissionRequest> = {
  encode(message: UpdateSubmissionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.submissionId !== "") {
      writer.uint32(10).string(message.submissionId);
    }
    if (message.state !== 0) {
      writer.uint32(16).int32(message.state);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateSubmissionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSubmissionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.submissionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSubmissionRequest {
    return {
      submissionId: isSet(object.submissionId) ? globalThis.String(object.submissionId) : "",
      state: isSet(object.state) ? submissionStateFromJSON(object.state) : 0,
    };
  },

  toJSON(message: UpdateSubmissionRequest): unknown {
    const obj: any = {};
    if (message.submissionId !== "") {
      obj.submissionId = message.submissionId;
    }
    if (message.state !== 0) {
      obj.state = submissionStateToJSON(message.state);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateSubmissionRequest>, I>>(base?: I): UpdateSubmissionRequest {
    return UpdateSubmissionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateSubmissionRequest>, I>>(object: I): UpdateSubmissionRequest {
    const message = createBaseUpdateSubmissionRequest();
    message.submissionId = object.submissionId ?? "";
    message.state = object.state ?? 0;
    return message;
  },
};

export interface Manager {
  Register(request: AuthenticationRequest): Promise<AuthenticationResponse>;
  Login(request: AuthenticationRequest): Promise<AuthenticationResponse>;
  ChangeRole(request: ChangeRoleRequest): Promise<Empty>;
  GetProfile(request: ID): Promise<GetProfileResponse>;
  GetProfiles(request: Empty): Promise<GetProfilesResponse>;
  GetStatsRequest(request: ID): Promise<GetStatsResponse>;
  GetQuestions(request: GetQuestionsRequest): Promise<GetQuestionsResponse>;
  GetQuestion(request: ID): Promise<GetQuestionResponse>;
  Submit(request: SubmitRequest): Promise<Empty>;
  GetSubmissions(request: GetSubmissionsRequest): Promise<GetSubmissionsResponse>;
  CreateQuestion(request: Question): Promise<ID>;
  EditQuestion(request: Question): Promise<Empty>;
  ChangeQuestionState(request: ChangeQuestionStateRequest): Promise<Empty>;
  UpdateSubmission(request: Submission): Promise<Empty>;
}

export const ManagerServiceName = "proto.Manager";
export class ManagerClientImpl implements Manager {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || ManagerServiceName;
    this.rpc = rpc;
    this.Register = this.Register.bind(this);
    this.Login = this.Login.bind(this);
    this.ChangeRole = this.ChangeRole.bind(this);
    this.GetProfile = this.GetProfile.bind(this);
    this.GetProfiles = this.GetProfiles.bind(this);
    this.GetStatsRequest = this.GetStatsRequest.bind(this);
    this.GetQuestions = this.GetQuestions.bind(this);
    this.GetQuestion = this.GetQuestion.bind(this);
    this.Submit = this.Submit.bind(this);
    this.GetSubmissions = this.GetSubmissions.bind(this);
    this.CreateQuestion = this.CreateQuestion.bind(this);
    this.EditQuestion = this.EditQuestion.bind(this);
    this.ChangeQuestionState = this.ChangeQuestionState.bind(this);
    this.UpdateSubmission = this.UpdateSubmission.bind(this);
  }
  Register(request: AuthenticationRequest): Promise<AuthenticationResponse> {
    const data = AuthenticationRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Register", data);
    return promise.then((data) => AuthenticationResponse.decode(new BinaryReader(data)));
  }

  Login(request: AuthenticationRequest): Promise<AuthenticationResponse> {
    const data = AuthenticationRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Login", data);
    return promise.then((data) => AuthenticationResponse.decode(new BinaryReader(data)));
  }

  ChangeRole(request: ChangeRoleRequest): Promise<Empty> {
    const data = ChangeRoleRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ChangeRole", data);
    return promise.then((data) => Empty.decode(new BinaryReader(data)));
  }

  GetProfile(request: ID): Promise<GetProfileResponse> {
    const data = ID.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetProfile", data);
    return promise.then((data) => GetProfileResponse.decode(new BinaryReader(data)));
  }

  GetProfiles(request: Empty): Promise<GetProfilesResponse> {
    const data = Empty.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetProfiles", data);
    return promise.then((data) => GetProfilesResponse.decode(new BinaryReader(data)));
  }

  GetStatsRequest(request: ID): Promise<GetStatsResponse> {
    const data = ID.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetStatsRequest", data);
    return promise.then((data) => GetStatsResponse.decode(new BinaryReader(data)));
  }

  GetQuestions(request: GetQuestionsRequest): Promise<GetQuestionsResponse> {
    const data = GetQuestionsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetQuestions", data);
    return promise.then((data) => GetQuestionsResponse.decode(new BinaryReader(data)));
  }

  GetQuestion(request: ID): Promise<GetQuestionResponse> {
    const data = ID.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetQuestion", data);
    return promise.then((data) => GetQuestionResponse.decode(new BinaryReader(data)));
  }

  Submit(request: SubmitRequest): Promise<Empty> {
    const data = SubmitRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Submit", data);
    return promise.then((data) => Empty.decode(new BinaryReader(data)));
  }

  GetSubmissions(request: GetSubmissionsRequest): Promise<GetSubmissionsResponse> {
    const data = GetSubmissionsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetSubmissions", data);
    return promise.then((data) => GetSubmissionsResponse.decode(new BinaryReader(data)));
  }

  CreateQuestion(request: Question): Promise<ID> {
    const data = Question.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateQuestion", data);
    return promise.then((data) => ID.decode(new BinaryReader(data)));
  }

  EditQuestion(request: Question): Promise<Empty> {
    const data = Question.encode(request).finish();
    const promise = this.rpc.request(this.service, "EditQuestion", data);
    return promise.then((data) => Empty.decode(new BinaryReader(data)));
  }

  ChangeQuestionState(request: ChangeQuestionStateRequest): Promise<Empty> {
    const data = ChangeQuestionStateRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ChangeQuestionState", data);
    return promise.then((data) => Empty.decode(new BinaryReader(data)));
  }

  UpdateSubmission(request: Submission): Promise<Empty> {
    const data = Submission.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateSubmission", data);
    return promise.then((data) => Empty.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
